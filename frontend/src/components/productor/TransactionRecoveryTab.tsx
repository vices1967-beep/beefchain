// src/components/productor/TransactionRecoveryTab.tsx - VERSI√ìN COMPLETA MEJORADA
'use client';

import { useState } from 'react';
import { useStarknet } from '@/providers/starknet-provider';
import { RazaAnimal } from '@/contracts/config';
import { cacheService } from '@/services/CacheService';

const convertBigIntToString = (obj: any): any => {
  if (obj === null || obj === undefined) return obj;
  if (typeof obj === 'bigint') return obj.toString();
  if (Array.isArray(obj)) return obj.map(convertBigIntToString);
  if (typeof obj === 'object') {
    const newObj: any = {};
    for (const key in obj) {
      newObj[key] = convertBigIntToString(obj[key]);
    }
    return newObj;
  }
  return obj;
};

export function TransactionRecoveryTab() {
  const { contractService } = useStarknet();
  const [missingTxHash, setMissingTxHash] = useState<string>('0x7d75f6c8cb306bca3d79015c86f5f40b047891176b9fdc6a9063f7477daf4df');
  const [blockNumber, setBlockNumber] = useState<string>('');
  const [isRecovering, setIsRecovering] = useState<boolean>(false);
  const [recoveryResult, setRecoveryResult] = useState<string>('');
  const [recoveredAnimalId, setRecoveredAnimalId] = useState<string>('');
  const [txDetails, setTxDetails] = useState<any>(null);

  // ‚úÖ FUNCI√ìN: Debuggear endpoints de cache
  const debugCacheEndpoints = async () => {
    console.log('üîç Debuggeando endpoints de cache...');
    setRecoveryResult('üîç Debuggeando endpoints de cache...');
    
    try {
      const diagnostic = await cacheService.fullDiagnostic();
      console.log('üìä Diagn√≥stico completo:', diagnostic);
      
      let resultText = 'üîç DIAGN√ìSTICO DE ENDPOINTS:\n\n';
      
      diagnostic.endpointTests?.forEach((test: any) => {
        resultText += `${test.endpoint}: ${test.success ? '‚úÖ FUNCIONA' : '‚ùå FALLA'}\n`;
        if (test.error) {
          resultText += `   Error: ${test.error}\n`;
        }
        if (test.serverError) {
          resultText += `   Error del servidor: ${test.serverError}\n`;
        }
        resultText += '\n';
      });
      
      resultText += `üìä Estad√≠sticas: ${JSON.stringify(diagnostic.stats?.summary, null, 2)}\n`;
      resultText += `üîÑ Estado: ${diagnostic.status}\n`;
      resultText += `üåê URL: ${diagnostic.baseURL}`;
      
      setRecoveryResult(resultText);
      
    } catch (error: any) {
      setRecoveryResult(`‚ùå Error en diagn√≥stico: ${error.message}`);
    }
  };

  // ‚úÖ FUNCI√ìN: Verificar conexi√≥n con cache usando el nuevo servicio
  const testCacheConnection = async () => {
    console.log('üîç [RECOVERY] Probando conexi√≥n con cache...');
    setRecoveryResult('üîç Probando conexi√≥n con cache...');
    
    try {
      // Usar el m√©todo de conexi√≥n autom√°tica del nuevo servicio
      const connected = await cacheService.autoConnect();
      
      if (connected) {
        const currentURL = cacheService.getBaseURL();
        const health = await cacheService.healthCheck();
        
        setRecoveryResult(`‚úÖ Conexi√≥n con cache: FUNCIONA\nURL: ${currentURL}\nEstado: ${health?.status || 'healthy'}`);
        console.log('‚úÖ [RECOVERY] Cache disponible:', health);
      } else {
        const connectionTest = await cacheService.testConnection();
        setRecoveryResult(`‚ùå Conexi√≥n con cache: FALL√ì\n\nServidores probados:\n${connectionTest.results.map((r: any) => `‚Ä¢ ${r.url}: ${r.status}`).join('\n')}`);
        console.warn('‚ùå [RECOVERY] Cache no disponible');
      }
    } catch (error: any) {
      setRecoveryResult('‚ùå Error probando conexi√≥n: ' + error.message);
      console.error('‚ùå [RECOVERY] Error probando conexi√≥n:', error);
    }
  };

  // ‚úÖ FUNCI√ìN: Obtener datos REALES del animal de Starknet
  const getAnimalDataFromStarknet = async (animalId: bigint) => {
    if (!contractService) {
      throw new Error('Servicio de contrato no disponible');
    }

    try {
      const animalData = await contractService.getAnimalData(animalId);
      console.log(`‚úÖ [DEBUG] Datos procesados animal #${animalId}:`, animalData);
      return {
        ...animalData,
        animalId: animalId
      };
    } catch (error: any) {
      throw new Error(`No se pudieron obtener los datos del animal desde Starknet: ${error.message}`);
    }
  };

  // ‚úÖ FUNCI√ìN MEJORADA: Recuperar transacci√≥n perdida y guardar en cache
  const recoverMissingTransaction = async () => {
    if (!contractService || !missingTxHash) {
      setRecoveryResult('‚ùå Servicio de contrato no disponible o hash inv√°lido');
      return;
    }

    setIsRecovering(true);
    setRecoveryResult('');
    setRecoveredAnimalId('');
    setTxDetails(null);

    try {
      console.log(`üîç [RECOVERY] Recuperando transacci√≥n: ${missingTxHash}`);
      setRecoveryResult('üîç Iniciando recuperaci√≥n...');
      
      // Primero verificar conexi√≥n con cache usando el nuevo servicio
      setRecoveryResult('üè• Verificando conexi√≥n con cache...');
      const cacheHealth = await cacheService.healthCheck();
      if (!cacheHealth || !(cacheHealth.status === 'healthy' || cacheHealth.status === 'ok')) {
        setRecoveryResult('‚ùå El servidor de cache no est√° disponible.\nEstado: ' + (cacheHealth?.status || 'unknown'));
        setIsRecovering(false);
        return;
      }
      
      setRecoveryResult('‚úÖ Cache disponible. Buscando animales en Starknet...');
      
      // ‚úÖ BUSCAR animales por transacci√≥n
      const animalIds = await contractService.findAnimalsByTransaction(missingTxHash);
      
      if (animalIds.length > 0) {
        console.log(`üéØ [RECOVERY] ${animalIds.length} animales encontrados en transacci√≥n:`, animalIds);
        setRecoveryResult(`üéØ ${animalIds.length} animal(es) encontrado(s) en la transacci√≥n...`);
        
        let animalsRecovered = 0;
        let animalsSkipped = 0;
        let animalsFailed = 0;

        for (const animalId of animalIds) {
          try {
            const animalIdStr = animalId.toString();
            setRecoveredAnimalId(animalIdStr);
            
            // Obtener datos REALES del animal
            const animalData = await getAnimalDataFromStarknet(animalId);
            
            // Verificar si ya existe en cache
            const existingAnimal = await cacheService.getAnimalById(animalIdStr);
            
            if (existingAnimal && existingAnimal.success) {
              setRecoveryResult(prev => prev + `\n‚ÑπÔ∏è Animal #${animalIdStr} ya existe en cache`);
              animalsSkipped++;
            } else {
              setRecoveryResult(prev => prev + `\nüíæ Guardando animal #${animalIdStr} en cache...`);
              
              // ‚úÖ CREAR DATOS SIMPLIFICADOS para evitar errores del servidor
              const animalCacheData = {
                id: animalIdStr,
                nombre: `Animal Recuperado #${animalIdStr}`,
                propietario_actual: animalData.propietario || '0x0',
                raza: animalData.raza || RazaAnimal.ANGUS,
                estado: 'activo',
                fecha_creacion: Math.floor(Date.now() / 1000),
                tx_hash: missingTxHash,
                
                // Campos opcionales - solo si son necesarios
                genero: 'M',
                alimentacion: 'P',
                metadata_hash: '0x0',
                numero_identificacion: `REC-${animalIdStr}`,
                
                // Datos de Starknet para referencia
                starknet_data: convertBigIntToString(animalData)
              };

              console.log(`üì§ Enviando datos simplificados para animal #${animalIdStr}:`, animalCacheData);
              
              const result = await cacheService.addAnimal(animalCacheData);
              
              if (result && result.success) {
                setRecoveryResult(prev => prev + `\n‚úÖ Animal #${animalIdStr} recuperado exitosamente`);
                animalsRecovered++;
              } else {
                const errorMsg = result?.error || result?.serverError || 'Error desconocido';
                setRecoveryResult(prev => prev + `\n‚ùå Error guardando animal #${animalIdStr}: ${errorMsg}`);
                animalsFailed++;
              }
            }
          } catch (animalError: any) {
            console.error(`[RECOVERY] Error procesando animal ${animalId}:`, animalError);
            setRecoveryResult(prev => prev + `\n‚ö†Ô∏è Error procesando animal #${animalId}: ${animalError.message}`);
            animalsFailed++;
          }
        }

        // Resumen final
        setRecoveryResult(prev => prev + `\n\nüéâ PROCESO COMPLETADO:`);
        setRecoveryResult(prev => prev + `\n‚úÖ ${animalsRecovered} animal(es) recuperado(s)`);
        setRecoveryResult(prev => prev + `\n‚ÑπÔ∏è ${animalsSkipped} animal(es) ya exist√≠an`);
        setRecoveryResult(prev => prev + `\n‚ùå ${animalsFailed} animal(es) con errores`);

      } else {
        setRecoveryResult('‚ùå No se encontraron animales en esta transacci√≥n');
      }
    } catch (error: any) {
      console.error('‚ùå [RECOVERY] Error recuperando transacci√≥n:', error);
      setRecoveryResult(`‚ùå Error: ${error.message}`);
    } finally {
      setIsRecovering(false);
    }
  };

  // ‚úÖ FUNCI√ìN MEJORADA: Sincronizar todos los animales del usuario
  const syncAllUserAnimals = async () => {
    if (!contractService) {
      setRecoveryResult('‚ùå Servicio de contrato no disponible');
      return;
    }

    setIsRecovering(true);
    setRecoveryResult('');

    try {
      console.log('üîÑ [RECOVERY] Sincronizando todos los animales del usuario...');
      setRecoveryResult('üîÑ Iniciando sincronizaci√≥n completa...');
      
      // Primero verificar conexi√≥n con cache
      setRecoveryResult('üè• Verificando conexi√≥n con cache...');
      const cacheHealth = await cacheService.healthCheck();
      if (!cacheHealth || !(cacheHealth.status === 'healthy' || cacheHealth.status === 'ok')) {
        setRecoveryResult('‚ùå El servidor de cache no est√° disponible.\nEstado: ' + (cacheHealth?.status || 'unknown'));
        setIsRecovering(false);
        return;
      }

      setRecoveryResult('üîç Obteniendo animales desde Starknet...');
      
      // Obtener todos los animales del usuario desde Starknet
      const userAddress = contractService.getUserAddress();
      const userAnimals = await contractService.getAnimalsByProducer(userAddress);
      
      console.log(`üìä [RECOVERY] ${userAnimals.length} animales encontrados en Starknet:`, userAnimals);
      setRecoveryResult(`üìä ${userAnimals.length} animales encontrados en Starknet...`);
      
      let animalsSynced = 0;
      let animalsSkipped = 0;
      let animalsFailed = 0;

      // Procesar cada animal
      for (const animalId of userAnimals) {
        try {
          const animalIdStr = animalId.toString();
          setRecoveredAnimalId(animalIdStr);
          
          // Obtener datos REALES del animal
          const animalData = await getAnimalDataFromStarknet(animalId);
          
          // Verificar si ya existe en cache
          const existingAnimal = await cacheService.getAnimalById(animalIdStr);
          
          if (existingAnimal && existingAnimal.success) {
            console.log(`‚ÑπÔ∏è [RECOVERY] Animal #${animalIdStr} ya existe en cache`);
            animalsSkipped++;
          } else {
            console.log(`üíæ [RECOVERY] Sincronizando animal #${animalIdStr}...`);
            setRecoveryResult(prev => prev + `\nüíæ Sincronizando animal #${animalIdStr}...`);
            
            // ‚úÖ CREAR DATOS SIMPLIFICADOS para evitar errores del servidor
            const animalCacheData = {
              id: animalIdStr,
              nombre: `Animal Sincronizado #${animalIdStr}`,
              propietario_actual: animalData.propietario || contractService.getUserAddress() || '0x0',
              raza: animalData.raza || RazaAnimal.ANGUS,
              estado: 'activo',
              fecha_creacion: Math.floor(Date.now() / 1000),
              tx_hash: 'sync-' + Date.now(),
              
              // Campos opcionales
              genero: 'M',
              alimentacion: 'P',
              metadata_hash: '0x0',
              numero_identificacion: `SYNC-${animalIdStr}`,
              
              // Datos de Starknet para referencia
              starknet_data: convertBigIntToString(animalData)
            };

            console.log(`üì§ Enviando datos simplificados para animal #${animalIdStr}:`, animalCacheData);
            
            const result = await cacheService.addAnimal(animalCacheData);
            
            if (result && result.success) {
              setRecoveryResult(prev => prev + `\n‚úÖ Animal #${animalIdStr} sincronizado exitosamente`);
              animalsSynced++;
            } else {
              const errorMsg = result?.error || result?.serverError || 'Error desconocido';
              setRecoveryResult(prev => prev + `\n‚ùå Error sincronizando animal #${animalIdStr}: ${errorMsg}`);
              animalsFailed++;
            }
          }
        } catch (animalError: any) {
          console.error(`[RECOVERY] Error procesando animal ${animalId}:`, animalError);
          setRecoveryResult(prev => prev + `\n‚ö†Ô∏è Error procesando animal #${animalId}: ${animalError.message}`);
          animalsFailed++;
        }
      }

      // Resumen final
      setRecoveryResult(prev => prev + `\n\nüéâ SINCRONIZACI√ìN COMPLETADA:`);
      setRecoveryResult(prev => prev + `\n‚úÖ ${animalsSynced} animales sincronizados`);
      setRecoveryResult(prev => prev + `\n‚ÑπÔ∏è ${animalsSkipped} animales ya exist√≠an`);
      setRecoveryResult(prev => prev + `\n‚ùå ${animalsFailed} animales con errores`);
      
    } catch (error: any) {
      console.error('‚ùå [RECOVERY] Error en sincronizaci√≥n:', error);
      setRecoveryResult(`‚ùå Error en sincronizaci√≥n: ${error.message}`);
    } finally {
      setIsRecovering(false);
    }
  };

  // ‚úÖ FUNCI√ìN: Limpiar formulario
  const clearForm = () => {
    setMissingTxHash('');
    setBlockNumber('');
    setRecoveryResult('');
    setRecoveredAnimalId('');
    setTxDetails(null);
  };

  return (
    <div className="space-y-6">
      <div className="bg-blue-50 border border-blue-200 rounded-xl p-5">
        <h4 className="font-semibold text-lg text-blue-800 mb-3 flex items-center gap-2">
          üîÑ Recuperar Transacci√≥n Perdida
        </h4>
        <p className="text-blue-700 text-sm">
          Recupera animales de transacciones que se ejecutaron en Starknet pero no se guardaron en el cache.
        </p>
      </div>

      {/* ‚úÖ Bot√≥n para debuggear endpoints */}
      <div className="border border-red-200 rounded-xl p-5 bg-red-50">
        <h5 className="font-semibold text-red-800 mb-3 flex items-center gap-2">
          üêõ Debug Endpoints
        </h5>
        <p className="text-red-700 text-sm mb-4">
          Debuggear por qu√© fallan los endpoints de escritura
        </p>
        <button
          onClick={debugCacheEndpoints}
          className="px-6 py-2 bg-red-500 text-white rounded-lg font-semibold hover:bg-red-600 transition-colors flex items-center justify-center gap-2"
        >
          üêõ Debug Endpoints
        </button>
      </div>

      {/* ‚úÖ Bot√≥n para probar conexi√≥n con cache */}
      <div className="border border-orange-200 rounded-xl p-5 bg-orange-50">
        <h5 className="font-semibold text-orange-800 mb-3 flex items-center gap-2">
          üîß Diagn√≥stico de Conexi√≥n
        </h5>
        <p className="text-orange-700 text-sm mb-4">
          Servicio de cache mejorado con conexi√≥n autom√°tica
        </p>
        <button
          onClick={testCacheConnection}
          className="px-6 py-2 bg-orange-500 text-white rounded-lg font-semibold hover:bg-orange-600 transition-colors flex items-center justify-center gap-2"
        >
          üîç Probar Conexi√≥n con Cache
        </button>
      </div>

      {/* ‚úÖ Bot√≥n de sincronizaci√≥n completa */}
      <div className="border border-purple-200 rounded-xl p-5 bg-purple-50">
        <h5 className="font-semibold text-purple-800 mb-3 flex items-center gap-2">
          üîÑ Sincronizaci√≥n Completa
        </h5>
        <p className="text-purple-700 text-sm mb-4">
          Sincroniza TODOS tus animales desde Starknet al cache. √ötil si faltan animales en la lista.
        </p>
        <button
          onClick={syncAllUserAnimals}
          disabled={isRecovering}
          className="px-6 py-2 bg-purple-500 text-white rounded-lg font-semibold hover:bg-purple-600 disabled:bg-purple-300 disabled:cursor-not-allowed transition-colors flex items-center justify-center gap-2"
        >
          {isRecovering ? (
            <>‚è≥ Sincronizando...</>
          ) : (
            <>üîÑ Sincronizar Todos mis Animales</>
          )}
        </button>
      </div>

      {/* Formulario de recuperaci√≥n */}
      <div className="border border-gray-200 rounded-xl p-5 bg-gray-50">
        <h5 className="font-semibold text-gray-800 mb-4">üìã Datos de la Transacci√≥n</h5>
        
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {/* Hash de Transacci√≥n */}
          <div className="md:col-span-2">
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Hash de Transacci√≥n *
            </label>
            <input
              type="text"
              value={missingTxHash}
              onChange={(e) => setMissingTxHash(e.target.value)}
              placeholder="0x7d75f6c8cb306bca3d79015c86f5f40b047891176b9fdc6a9063f7477daf4df"
              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors font-mono text-sm"
            />
          </div>

          {/* Botones */}
          <div className="flex items-end gap-3">
            <button
              onClick={recoverMissingTransaction}
              disabled={isRecovering || !missingTxHash}
              className="flex-1 px-6 py-2 bg-green-500 text-white rounded-lg font-semibold hover:bg-green-600 disabled:bg-green-300 disabled:cursor-not-allowed transition-colors flex items-center justify-center gap-2"
            >
              {isRecovering ? (
                <>‚è≥ Recuperando...</>
              ) : (
                <>üîç Recuperar Transacci√≥n</>
              )}
            </button>

            <button
              onClick={clearForm}
              disabled={isRecovering}
              className="px-4 py-2 bg-gray-500 text-white rounded-lg font-semibold hover:bg-gray-600 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors"
            >
              üóëÔ∏è Limpiar
            </button>
          </div>
        </div>
      </div>

      {/* Resultados */}
      {recoveryResult && (
        <div className={`border rounded-xl p-5 ${
          recoveryResult.includes('‚úÖ') || recoveryResult.includes('üéâ') 
            ? 'bg-green-50 border-green-200' 
            : recoveryResult.includes('‚ùå') 
            ? 'bg-red-50 border-red-200'
            : 'bg-blue-50 border-blue-200'
        }`}>
          <h5 className="font-semibold mb-3 flex items-center gap-2">
            {recoveryResult.includes('‚úÖ') || recoveryResult.includes('üéâ') ? '‚úÖ' : 
             recoveryResult.includes('‚ùå') ? '‚ùå' : '‚ÑπÔ∏è'} Resultado
          </h5>
          <pre className="text-sm whitespace-pre-wrap font-sans">
            {recoveryResult}
          </pre>
        </div>
      )}

      {/* Informaci√≥n adicional */}
      <div className="text-xs text-gray-500 space-y-2 border-t pt-4">
        <p><strong>üí° C√≥mo usar:</strong></p>
        <p>1. Primero usa "Debug Endpoints" para ver qu√© endpoints est√°n funcionando</p>
        <p>2. Usa "Probar Conexi√≥n con Cache" para verificar que el servidor est√© disponible</p>
        <p>3. Si hay errores, usa "Sincronizar Todos mis Animales" para recuperar todo</p>
        <p>4. Para una transacci√≥n espec√≠fica, ingresa el hash y haz clic en "Recuperar Transacci√≥n"</p>
        <p className="text-blue-600"><strong>Caracter√≠sticas del nuevo servicio:</strong> Conexi√≥n autom√°tica, reintentos, manejo robusto de errores, debug detallado</p>
      </div>
    </div>
  );
}